import re
import logging
from typing import Dict, List, Any

logger = logging.getLogger(__name__)

def parse_items_file(content: str) -> Dict[str, Dict[str, Any]]:
    """
    Parses an OpenHAB .items file content into a dictionary.
    Returns: {item_name: {type, label, icon, groups, tags, channel}}
    """
    items = {}
    # Basic regex to capture: Type Name "Label" <Icon> (Groups) ["Tags"] {Channel}
    # This is a simplification and might need adjustment for complex cases
    line_pattern = re.compile(
        r'^\s*(?P<type>[\w:]+)\s+'
        r'(?P<name>\w+)\s+'
        r'(?:"(?P<label>[^"]*)"\s*)?'
        r'(?:<(?P<icon>\w*)>\s*)?'
        r'(?:\((?P<groups>[^)]*)\)\s*)?'
        r'(?:\[(?P<tags>[^\]]*)\].*)?'
        r'(?:\{(?P<metadata>.*)\})?'
    )

    for line in content.splitlines():
        line = line.strip()
        if not line or line.startswith("//"):
            continue
        
        match = line_pattern.match(line)
        if match:
            data = match.groupdict()
            name = data['name']
            
            # Parse groups
            groups = [g.strip() for g in data['groups'].split(',')] if data['groups'] else []
            
            # Parse tags
            tags = [t.strip().strip('"') for t in data['tags'].split(',')] if data['tags'] else []

            # Parse channel from metadata if present (simplified)
            channel = None
            if data['metadata'] and 'channel=' in data['metadata']:
                # Extract channel="foo" or channel="foo,bar"
                # This is a rough extraction
                channel_match = re.search(r'channel="([^"]+)"', data['metadata'])
                if channel_match:
                    channel = channel_match.group(1)

            items[name] = {
                'type': data['type'],
                'label': data['label'],
                'icon': data['icon'],
                'groups': groups,
                'tags': tags,
                'channel': channel,
                'raw': line
            }
    return items

def parse_things_file(content: str) -> Dict[str, Any]:
    """
    Parses an OpenHAB .things file content to extract Thing definitions and channels.
    Returns a simplified structure: {thing_id: {channels: {id: config}}}
    """
    things = {}
    
    # We are mainly interested in the channels configuration to verify GAs
    # This regex looks for Thing device ... { ... Channels: ... }
    # Since Things structure is multi-line, regex is tricky. 
    # Let's try to extract "Thing device <name> [ ... ] { ... }" blocks first
    
    # Simple approach: Find all "Thing device" blocks
    # Then inside, find Channels
    
    # For now, let's just find all lines defining a channel Type
    # Type switch : ch1 "Label" [ ga="1/0/1+<1/0/2" ]
    
    channel_pattern = re.compile(
        r'\s*Type\s+(?P<type>\w+)\s*:\s*(?P<id>[\w\-_]+)\s*".*?"\s*\[\s*(?P<config>.*)\s*\]'
    )
    
    # We assume one big Bridge or multiple Things.
    # Let's collect all found channels independent of the Thing for global validation
    all_channels = {}

    for line in content.splitlines():
        match = channel_pattern.search(line)
        if match:
            data = match.groupdict()
            channel_id = data['id']
            config_str = data['config']
            
            # Extract ga="xyz"
            ga = None
            ga_match = re.search(r'ga="([^"]+)"', config_str)
            if ga_match:
                ga = ga_match.group(1)
            
            all_channels[channel_id] = {
                'type': data['type'],
                'ga': ga
            }
            
    return {'channels': all_channels}


def validate_project_structure(items: Dict[str, Any], project_node: Dict[str, Any]) -> List[str]:
    """
    Validates that the generated items match the KNX project structure (Floors/Rooms).
    """
    errors = []
    
    # Project node is expected to be the root or containing 'floors'
    # Based on earlier research: house[0]['floors']
    
    # We need to construct what we expect.
    # If project_node isn't the 'house' list from `knxproject_to_openhab`, 
    # but the raw JSON from `knxproject_to_openhab.py` logic, we need to adapt.
    # But wait, `knxproject_to_openhab.py` produces an internal structure `house`.
    # The test will have access to the processed `house` object or the input JSON.
    
    # Let's assume we pass the `house` object (list of buildings) generated by `create_building` etc.
    # or we traverse the `ets_to_openhab.floors` variable if we can access it.
    
    # For semantic validation, we might just look at the raw expectation vs output.
    # But let's work with the "house" dictionary structure produced by `knxproject_to_openhab`
    # because that is the source of truth for the generator.
    
    # house structure example:
    # [{'name': 'Building', 'floors': [{'name': 'EG', 'rooms': [{'name': 'Living', 'items': [...]}]}]}]

    if not isinstance(project_node, list) or not project_node:
        return ["Invalid project structure provided for validation"]

    building = project_node[0] # Assume 1 building
    
    floors = building.get('floors', [])
    for floor in floors:
        floor_name = floor.get('name')
        logger.debug(f"Validating Floor: {floor_name}")
        # Check if Floor Group exists
        # Name logic in `ets_to_openhab.py`: `generate_floor_configuration`
        # It seems to use the floor name directly or normalized.
        # Let's check if we can find a Group Item that looks like likely related.
        
        # Strict check might be hard if we don't know the exact normalization logic here.
        # But broadly, we look for items with tag "Location"? 
        # Or we rely on the implementation details we know (e.g. prefix).
        
        # Let's just check if we can find the Group by its name if possible.
        # or checking if at LEAST one group exists that *contains* the rooms.
        
        rooms = floor.get('rooms', [])
        for room in rooms:
            room_name = room.get('name')
            if not room_name:
                continue

            # Check if Room Group exists
            # We look for a Group item with this name (normalized?)
            logger.debug(f"  Validating Room: {room_name}")
            
            found_room = False
            for item_name, item_data in items.items():
                label = item_data.get('label')
                if item_data['type'].startswith('Group') and label and room_name in label: 
                    # Loose matching on label if name is transformed
                   found_room = True
                   break
                if item_name == room_name:
                    found_room = True
                    break
            
            if not found_room:
                errors.append(f"Missing Room Group for '{room_name}' in Floor '{floor_name}'")

    return errors

def validate_devices(items: Dict[str, Any], things: Dict[str, Any], all_addresses: List[Dict[str, Any]]) -> List[str]:
    """
    Validates that devices defined by addresses are present in Items and Things.
    """
    errors = []
    
    # `all_addresses` contains the flat list of KNX objects with 'name', 'address', 'floor', 'room' etc.
    # processed by `knxproject_to_openhab.py`.
    
    # We want to check that for major functions, we have items.
    
    for addr in all_addresses:
        # We only really care about "valid" functional addresses, not every single GA.
        # `knxproject_to_openhab.py` groups these.
        # But `all_addresses` is a list of dicts.
        
        # We can check specific interesting patterns. 
        # For example, if we have a "Dimmer", we expect a Dimmer Item.
        
        # This part requires deep knowledge of how existing code groups things.
        # For now, let's implement a sanity check on GAs usage.
        
        knx_address = addr.get('address') # '1/1/1'
        
        # Check if this address is used in Things (if it is substantial)
        # Some addresses might be passive.
        
        pass

    return errors
